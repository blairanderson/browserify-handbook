{"name":"Browserify-handbook","tagline":"how to build modular applications with browserify","body":"# introduction\r\n\r\nThis document covers how to use [browserify](http://browserify.org) to build\r\nmodular applications.\r\n\r\n[![cc-by-3.0](http://i.creativecommons.org/l/by/3.0/80x15.png)](http://creativecommons.org/licenses/by/3.0/)\r\n\r\nbrowserify is a tool for compiling\r\n[node-flavored](http://nodejs.org/docs/latest/api/modules.html) commonjs modules\r\nfor the browser.\r\n\r\nYou can use browserify to organize your code and use third-party libraries even\r\nif you don't use [node](http://nodejs.org) itself in any other capacity except\r\nfor bundling and installing packages with npm.\r\n\r\nThe module system that browserify uses is the same as node, so\r\npackages published to [npm](https://npmjs.org) that were originally intended for\r\nuse in node but not browsers will work just fine in the browser too.\r\n\r\nIncreasingly, people are publishing modules to npm which are intentionally\r\ndesigned to work in both node and in the browser using browserify and many\r\npackages on npm are intended for use in just the browser.\r\n[npm is for all javascript](http://maxogden.com/node-packaged-modules.html),\r\nfront or backend alike.\r\n\r\n# table of contents\r\n\r\n- [introduction](#introduction)\r\n- [table of contents](#table-of-contents)\r\n- [node packaged manuscript](#node-packaged-manuscript)\r\n- [node packaged modules](#node-packaged-modules)\r\n  - [require](#require)\r\n  - [exports](#exports)\r\n  - [bundling for the browser](#bundling-for-the-browser)\r\n  - [how browserify works](#how-browserify-works)\r\n  - [how node_modules works](#how-node_modules-works)\r\n  - [why concatenate](#why-concatenate)\r\n- [development](#development)\r\n  - [source maps](#source-maps)\r\n  - [auto-recompile](#auto-recompile)\r\n  - [using the api directly](#using-the-api-directly)\r\n  - [grunt](#grunt)\r\n  - [gulp](#gulp)\r\n- [builtins](#builtins)\r\n  - [Buffer](#Buffer)\r\n  - [process](#process)\r\n  - [global](#global)\r\n  - [__filename](#__filename)\r\n  - [__dirname](#__dirname)\r\n- [transforms](#transforms)\r\n  - [writing your own](#writing-your-own)\r\n- [package.json](#package.json)\r\n  - [browser field](#browser-field)\r\n  - [browserify.transform field](#browserifytransform-field)\r\n- [finding good modules](#finding-good-modules)\r\n  - [module philosophy](#module-philosophy)\r\n- [organizing modules](#organizing-modules)\r\n  - [avoiding ../../../../../../..](#avoiding-../../../../../../..)\r\n  - [non-javascript assets](#non-javascript-assets)\r\n  - [reusable components](#reusable-components)\r\n- [testing in node and the browser](#testing-in-node-and-the-browser)\r\n  - [testing libraries](#testing-libraries)\r\n  - [code coverage](#code-coverage)\r\n  - [testling-ci](#testling-ci)\r\n- [bundling](#bundling)\r\n  - [saving bytes](#saving-bytes)\r\n  - [standalone](#standalone)\r\n  - [external bundles](#external-bundles)\r\n  - [ignoring and excluding](#ignoring-and-excluding)\r\n  - [browserify cdn](#browserify-cdn)\r\n- [compiler pipeline](#compiler-pipeline)\r\n  - [module-deps](#module-deps)\r\n  - [browser-pack](#browser-pack)\r\n  - [insert-module-globals](#insert-module-globals)\r\n  - [build your own browserify](#build-your-own-browserify)\r\n  - [browser-unpack](#browser-unpack)\r\n  - [plugins](#plugins)\r\n\r\n# node packaged manuscript\r\n\r\nYou can install this handbook with npm, appropriately enough. Just do:\r\n\r\n```\r\nnpm install -g browserify-handbook\r\n```\r\n\r\nNow you will have a `browserify-handbook` command that will open this readme\r\nfile in your `$PAGER`. Otherwise, you may continue reading this document as you\r\nare presently doing.\r\n\r\n# node packaged modules\r\n\r\nBefore we can dive too deeply into how to use browserify and how it works, it is\r\nimportant to first understand how the\r\n[node-flavored version](http://nodejs.org/docs/latest/api/modules.html)\r\nof the commonjs module system works.\r\n\r\n## require\r\n\r\nIn node, there is a `require()` function for loading code from other files.\r\n\r\nIf you install a module with [npm](https://npmjs.org):\r\n\r\n```\r\nnpm install uniq\r\n```\r\n\r\nThen in a file `nums.js` we can `require('uniq')`:\r\n\r\n```\r\nvar uniq = require('uniq');\r\nvar nums = [ 5, 2, 1, 3, 2, 5, 4, 2, 0, 1 ];\r\nconsole.log(uniq(nums));\r\n```\r\n\r\nThe output of this program when run with node is:\r\n\r\n```\r\n$ node nums.js\r\n[ 0, 1, 2, 3, 4, 5 ]\r\n```\r\n\r\nYou can require relative files by requiring a string that starts with a `.`. For\r\nexample, to load a file `foo.js` from `main.js`, in `main.js` you can do:\r\n\r\n``` js\r\nvar foo = require('./foo.js');\r\nconsole.log(foo(4));\r\n```\r\n\r\nIf `foo.js` was in the parent directory, you could use `../foo.js` instead:\r\n\r\n``` js\r\nvar foo = require('../foo.js');\r\nconsole.log(foo(4));\r\n```\r\n\r\nor likewise for any other kind of relative path. Relative paths are always\r\nresolved with respect to the invoking file's location.\r\n\r\nNote that `require()` returned a function and we assigned that return value to a\r\nvariable called `uniq`. We could have picked any other name and it would have\r\nworked the same. `require()` returns the exports of the module name that you\r\nspecify.\r\n\r\nHow `require()` works is unlike many other module systems where imports are akin\r\nto statements that expose themselves as globals or file-local lexicals with\r\nnames declared in the module itself outside of your control. Under the node\r\nstyle of code import with `require()`, someone reading your program can easily\r\ntell where each piece of functionality came from. This approach scales much\r\nbetter as the number of modules in an application grows.\r\n\r\n## exports\r\n\r\nTo export a single thing from a file so that other files may import it, assign\r\nover the value at `module.exports`:\r\n\r\n``` js\r\nmodule.exports = function (n) {\r\n    return n * 111\r\n};\r\n```\r\n\r\nNow when some module `main.js` loads your `foo.js`, the return value of\r\n`require('./foo.js')` will be the exported function:\r\n\r\n``` js\r\nvar foo = require('./foo.js');\r\nconsole.log(foo(5));\r\n```\r\n\r\nThis program will print:\r\n\r\n```\r\n555\r\n```\r\n\r\nYou can export any kind of value with `module.exports`, not just functions.\r\n\r\nFor example, this is perfectly fine:\r\n\r\n``` js\r\nmodule.exports = 555\r\n```\r\n\r\nand so is this:\r\n\r\n``` js\r\nvar numbers = [];\r\nfor (var i = 0; i < 100; i++) numbers.push(i);\r\n\r\nmodule.exports = numbers;\r\n```\r\n\r\nThere is another form of doing exports specifically for exporting items onto an\r\nobject. Here, `exports` is used instead of `module.exports`:\r\n\r\n``` js\r\nexports.beep = function (n) { return n * 1000 }\r\nexports.boop = 555\r\n```\r\n\r\nThis program is the same as:\r\n\r\n``` js\r\nmodule.exports.beep = function (n) { return n * 1000 }\r\nmodule.exports.boop = 555\r\n```\r\n\r\nbecause `module.exports` is the same as `exports` and is initially set to an\r\nempty object.\r\n\r\nNote however that you can't do:\r\n\r\n``` js\r\n// this doesn't work\r\nexports = function (n) { return n * 1000 }\r\n```\r\n\r\nbecause the export value lives on the `module` object, and so assigning a new\r\nvalue for `exports` instead of `module.exports` masks the original reference. \r\n\r\nInstead if you are going to export a single item, always do:\r\n\r\n``` js\r\n// instead\r\nmodule.exports = function (n) { return n * 1000 }\r\n```\r\n\r\nIf you're still confused, try to understand how modules work in\r\nthe background:\r\n\r\n``` js\r\nvar module = {\r\n  exports: {}\r\n};\r\n\r\n// If you require a module, it's basically wrapped in a function\r\n(function(module, exports) {\r\n  exports = function (n) { return n * 1000 };\r\n}(module, module.exports))\r\n\r\nconsole.log(module.exports); // it's still an empty object :(\r\n```\r\n\r\nMost of the time, you will want to export a single function or constructor with\r\n`module.exports` because it's usually best for a module to do one thing.\r\n\r\nThe `exports` feature was originally the primary way of exporting functionality\r\nand `module.exports` was an afterthought, but `module.exports` proved to be much\r\nmore useful in practice at being more direct, clear, and avoiding duplication.\r\n\r\nIn the early days, this style used to be much more common:\r\n\r\nfoo.js:\r\n\r\n``` js\r\nexports.foo = function (n) { return n * 111 }\r\n```\r\n\r\nmain.js:\r\n\r\n``` js\r\nvar foo = require('./foo.js');\r\nconsole.log(foo.foo(5));\r\n```\r\n\r\nbut note that the `foo.foo` is a bit superfluous. Using `module.exports` it\r\nbecomes more clear:\r\n\r\nfoo.js:\r\n\r\n``` js\r\nmodule.exports = function (n) { return n * 111 }\r\n```\r\n\r\nmain.js:\r\n\r\n``` js\r\nvar foo = require('./foo.js');\r\nconsole.log(foo(5));\r\n```\r\n\r\n## bundling for the browser\r\n\r\nTo run a module in node, you've got to start from somewhere.\r\n\r\nIn node you pass a file to the `node` command to run a file:\r\n\r\n```\r\n$ node robot.js\r\nbeep boop\r\n```\r\n\r\nIn browserify, you do this same thing, but instead of running the file, you\r\ngenerate a stream of concatenated javascript files on stdout that you can write\r\nto a file with the `>` operator:\r\n\r\n```\r\n$ browserify robot.js > bundle.js\r\n```\r\n\r\nNow `bundle.js` contains all the javascript that `robot.js` needs to work.\r\nJust plop it into a single script tag in some html:\r\n\r\n``` html\r\n<html>\r\n  <body>\r\n    <script src=\"bundle.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\nBonus: if you put your script tag right before the `</body>`, you can use all of\r\nthe dom elements on the page without waiting for a dom onready event.\r\n\r\nThere are many more things you can do with bundling. Check out the bundling\r\nsection elsewhere in this document.\r\n\r\n## how browserify works\r\n\r\nBrowserify starts at the entry point files that you give it and searches for any\r\n`require()` calls it finds using\r\n[static analysis](http://npmjs.org/package/detective)\r\nof the source code's\r\n[abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree).\r\n\r\nFor every `require()` call with a string in it, browserify resolves those module\r\nstrings to file paths and then searches those file paths for `require()` calls\r\nrecursively until the entire dependency graph is visited.\r\n\r\nEach file is concatenated into a single javascript file with a minimal\r\n`require()` definition that maps the statically-resolved names to internal IDs.\r\n\r\nThis means that the bundle you generate is completely self-contained and has\r\neverything your application needs to work with a pretty negligible overhead.\r\n\r\nFor more details about how browserify works, check out the compiler pipeline\r\nsection of this document.\r\n\r\n## how node_modules works\r\n\r\nnode has a clever algorithm for resolving modules that is unique among rival\r\nplatforms.\r\n\r\nInstead of resolving packages from an array of system search paths like how\r\n`$PATH` works on the command line, node's mechanism is local by default.\r\n\r\nIf you `require('./foo.js')` from `/beep/boop/bar.js`, node will\r\nlook for `./foo.js` in `/beep/boop/foo.js`. Paths that start with a `./` or\r\n`../` are always local to the file that calls `require()`.\r\n\r\nIf however you require a non-relative name such as `require('xyz')` from\r\n`/beep/boop/foo.js`, node searches these paths in order, stopping at the first\r\nmatch and raising an error if nothing is found:\r\n\r\n```\r\n/beep/boop/node_modules/xyz\r\n/beep/node_modules/xyz\r\n/node_modules/xyz\r\n```\r\n\r\nFor each `xyz` directory that exists, node will first look for a\r\n`xyz/package.json` to see if a `\"main\"` field exists. The `\"main\"` field defines\r\nwhich file should take charge if you `require()` the directory path.\r\n\r\nFor example, if `/beep/node_modules/xyz` is the first match and\r\n`/beep/node_modules/xyz/package.json` has:\r\n\r\n```\r\n{\r\n  \"name\": \"xyz\",\r\n  \"version\": \"1.2.3\",\r\n  \"main\": \"lib/abc.js\"\r\n}\r\n```\r\n\r\nthen the exports from `/beep/node_modules/xyz/lib/abc.js` will be returned by\r\n`require('xyz')`.\r\n\r\nIf there is no `package.json` or no `\"main\"` field, `index.js` is assumed:\r\n\r\n```\r\n/beep/node_modules/xyz/index.js\r\n```\r\n\r\nIf you need to, you can reach into a package to pick out a particular file. For\r\nexample, to load the `lib/clone.js` file from the `dat` package, just do:\r\n\r\n```\r\nvar clone = require('dat/lib/clone.js')\r\n```\r\n\r\nThe recursive node_modules resolution will find the first `dat` package up the\r\ndirectory hierarchy, then the `lib/clone.js` file will be resolved from there.\r\nThis `require('dat/lib/clone.js')` approach will work from any location where\r\nyou can `require('dat')`.\r\n\r\nnode also has a mechanism for searching an array of paths, but this mechanism is\r\ndeprecated and you should be using `node_modules/` unless you have a very good\r\nreason not to.\r\n\r\nThe great thing about node's algorithm and how npm installs packages is that you\r\ncan never have a version conflict, unlike most every other platform. npm\r\ninstalls the dependencies of each package into `node_modules`.\r\n\r\nEach library gets its own local `node_modules/` directory where its dependencies\r\nare stored and each dependency's dependencies has its own `node_modules/`\r\ndirectory, recursively all the way down.\r\n\r\nThis means that packages can successfully use different versions of libraries in\r\nthe same application, which greatly decreases the coordination overhead\r\nnecessary to iterate on APIs. This feature is very important for an ecosystem\r\nlike npm where there is no central authority to manage how packages are\r\npublished and organized. Everyone may simply publish as they see fit and not\r\nworry about how their dependency version choices might impact other dependencies\r\nincluded in the same application.\r\n\r\nYou can leverage how `node_modules/` works to organize your own local\r\napplication modules too. See the `avoiding ../../../../../../..` section for\r\nmore.\r\n\r\n## why concatenate\r\n\r\nBrowserify is a build step that runs on the server. It generates a single bundle\r\nfile that has everything in it.\r\n\r\nHere are some other ways of implementing module systems for the browser and what\r\ntheir strengths and weaknesses are:\r\n\r\n### window globals\r\n\r\nInstead of a module system, each file defines properties on the window global\r\nobject or develops an internal namespacing scheme.\r\n\r\nThis approach does not scale well without extreme diligence since each new file\r\nneeds an additional `<script>` tag in all of the html pages where the\r\napplication will be rendered. Further, the files tend to be very order-sensitive\r\nbecause some files need to be included before other files the expect globals to\r\nalready be present in the environment.\r\n\r\nIt can be difficult to refactor or maintain applications built this way.\r\nOn the plus side, all browsers natively support this approach and no server-side\r\ntooling is required.\r\n\r\nThis approach tends to be very slow since each `<script>` tag initiates a\r\nnew round-trip http request.\r\n\r\n### concatenate\r\n\r\nInstead of window globals, all the scripts are concatenated beforehand on the\r\nserver. The code is still order-sensitive and difficult to maintain, but loads\r\nmuch faster because only a single http request for a single `<script>` tag needs\r\nto execute.\r\n\r\nWithout source maps, exceptions thrown will have offsets that can't be easily\r\nmapped back to their original files.\r\n\r\n### AMD\r\n\r\nInstead of using `<script>` tags, every file is wrapped with a `define()`\r\nfunction and callback. [This is AMD](http://requirejs.org/docs/whyamd.html). \r\n\r\nThe first argument is an array of modules to load that maps to each argument\r\nsupplied to the callback. Once all the modules are loaded, the callback fires.\r\n\r\n``` js\r\ndefine(['jquery'] , function ($) {\r\n    return function () {};\r\n});\r\n```\r\n\r\nYou can give your module a name in the first argument so that other modules can\r\ninclude it.\r\n\r\nThere is a commonjs sugar syntax that stringifies each callback and scans it for\r\n`require()` calls\r\n[with a regexp](https://github.com/jrburke/requirejs/blob/master/require.js#L17).\r\n\r\nCode written this way is much less order-sensitive than concatenation or globals\r\nsince the order is resolved by explicit dependency information.\r\n\r\nFor performance reasons, most of the time AMD is bundled server-side into a\r\nsingle file and during development it is more common to actually use the\r\nasynchronous feature of AMD.\r\n\r\n### bundling commonjs server-side\r\n\r\nIf you're going to have a build step for performance and a sugar syntax for\r\nconvenience, why not scrap the whole AMD business altogether and bundle\r\ncommonjs? With tooling you can resolve modules to address order-sensitivity and\r\nyour development and production environments will be much more similar and less\r\nfragile. The CJS syntax is nicer and the ecosystem is exploding because of node\r\nand npm.\r\n\r\nYou can seamlessly share code between node and the browser. You just need a\r\nbuild step and some tooling for source maps and auto-rebuilding.\r\n\r\nPlus, we can use node's module lookup algorithms to save us from version\r\nmismatch insanity so that we can have multiple conflicting versions of different\r\nrequired packages in the same application and everything will still work. To\r\nsave bytes down the wire you can dedupe, which is covered elsewhere in this\r\ndocument.\r\n\r\n# development\r\n\r\nConcatenation has some downsides, but these can be very adequately addressed\r\nwith development tooling.\r\n\r\n## source maps\r\n\r\nBrowserify supports a `--debug`/`-d` flag and `opts.debug` parameter to enable\r\nsource maps. Source maps tell the browser to convert line and column offsets for\r\nexceptions thrown in the bundle file back into the offsets and filenames of the\r\noriginal sources.\r\n\r\n## auto-recompile\r\n\r\nRunning a command to recompile your bundle every time can be slow and tedious.\r\nLuckily there are many tools to solve this problem.\r\n\r\n### [watchify](https://npmjs.org/package/watchify)\r\n\r\nYou can use `watchify` interchangeably with `browserify` but instead of writing\r\nto an output file once, watchify will write the bundle file and then watch all\r\nof the files in your dependency graph for changes. When you modify a file, the\r\nnew bundle file will be written much more quickly than the first time because of\r\naggressive caching.\r\n\r\nYou can use `-v` to print a message every time a new bundle is written:\r\n\r\n```\r\n$ watchify browser.js -d -o static/bundle.js -v\r\n610598 bytes written to static/bundle.js  0.23s\r\n610606 bytes written to static/bundle.js  0.10s\r\n610597 bytes written to static/bundle.js  0.14s\r\n610606 bytes written to static/bundle.js  0.08s\r\n610597 bytes written to static/bundle.js  0.08s\r\n610597 bytes written to static/bundle.js  0.19s\r\n```\r\n\r\nHere is a handy configuration for using watchify and browserify with the\r\npackage.json \"scripts\" field:\r\n\r\n``` json\r\n{\r\n  \"build\": \"browserify browser.js -o static/bundle.js\",\r\n  \"watch\": \"watchify browser.js -o static/bundle.js --debug --verbose\",\r\n}\r\n```\r\n\r\nTo build the bundle for production do `npm run build` and to watch files for\r\nduring development do `npm run watch`.\r\n\r\n[Learn more about `npm run`](http://substack.net/task_automation_with_npm_run).\r\n\r\n### [beefy](https://www.npmjs.org/package/beefy)\r\n\r\nIf you would rather spin up a web server that automatically recompiles your code\r\nwhen you modify it, check out [beefy](http://didact.us/beefy/).\r\n\r\nJust give beefy an entry file:\r\n\r\n```\r\nbeefy main.js\r\n```\r\n\r\nand it will set up shop on an http port.\r\n\r\n### browserify-middleware, enchilada\r\n\r\nIf you are using express, check out\r\n[browserify-middleware](https://www.npmjs.org/package/browserify-middleware)\r\nor [enchilada](https://www.npmjs.org/package/enchilada).\r\n\r\nThey both provide middleware you can drop into an express application for\r\nserving browserify bundles.\r\n\r\n## using the api directly\r\n\r\nYou can just use the API directly from an ordinary `http.createServer()` for\r\ndevelopment too:\r\n\r\n``` js\r\nvar browserify = require('browserify');\r\nvar http = require('http');\r\n\r\nhttp.createServer(function (req, res) {\r\n    if (req.url === '/bundle.js') {\r\n        res.setHeader('content-type', 'application/javascript');\r\n        var b = browserify(__dirname + '/main.js').bundle();\r\n        b.on('error', console.error);\r\n        b.pipe(res);\r\n    }\r\n    else res.writeHead(404, 'not found')\r\n});\r\n```\r\n\r\n## grunt\r\n\r\nIf you use grunt, you'll probably want to use the\r\n[grunt-browserify](https://www.npmjs.org/package/grunt-browserify) plugin.\r\n\r\n## gulp\r\n\r\nIf you use gulp, you should use the browserify API directly.\r\n\r\nHere is\r\n[a guide for getting started](http://viget.com/extend/gulp-browserify-starter-faq)\r\nwith gulp and browserify.\r\n\r\nHere is a guide on how to [make browserify builds fast with watchify using\r\ngulp](https://github.com/gulpjs/gulp/blob/master/docs/recipes/fast-browserify-builds-with-watchify.md)\r\nfrom the official gulp recipes.\r\n\r\n# builtins\r\n\r\nIn order to make more npm modules originally written for node work in the\r\nbrowser, browserify provides many browser-specific implementations of node core\r\nlibraries:\r\n\r\n* [assert](https://npmjs.org/package/assert)\r\n* [buffer](https://npmjs.org/package/buffer)\r\n* [console](https://npmjs.org/package/console-browserify)\r\n* [constants](https://npmjs.org/package/constants-browserify)\r\n* [crypto](https://npmjs.org/package/crypto-browserify)\r\n* [domain](https://npmjs.org/package/domain-browser)\r\n* [events](https://npmjs.org/package/events)\r\n* [http](https://npmjs.org/package/http-browserify)\r\n* [https](https://npmjs.org/package/https-browserify)\r\n* [os](https://npmjs.org/package/os-browserify)\r\n* [path](https://npmjs.org/package/path-browserify)\r\n* [punycode](https://npmjs.org/package/punycode)\r\n* [querystring](https://npmjs.org/package/querystring)\r\n* [stream](https://npmjs.org/package/stream-browserify)\r\n* [string_decoder](https://npmjs.org/package/string_decoder)\r\n* [timers](https://npmjs.org/package/timers-browserify)\r\n* [tty](https://npmjs.org/package/tty-browserify)\r\n* [url](https://npmjs.org/package/url)\r\n* [util](https://npmjs.org/package/util)\r\n* [vm](https://npmjs.org/package/vm-browserify)\r\n* [zlib](https://npmjs.org/package/browserify-zlib)\r\n\r\nevents, stream, url, path, and querystring are particularly useful in a browser\r\nenvironment.\r\n\r\nAdditionally, if browserify detects the use of `Buffer`, `process`, `global`,\r\n`__filename`, or `__dirname`, it will include a browser-appropriate definition.\r\n\r\nSo even if a module does a lot of buffer and stream operations, it will probably\r\njust work in the browser, so long as it doesn't do any server IO.\r\n\r\nIf you haven't done any node before, here are some examples of what each of\r\nthose globals can do. Note too that these globals are only actually defined when\r\nyou or some module you depend on uses them.\r\n\r\n## [Buffer](http://nodejs.org/docs/latest/api/buffer.html)\r\n\r\nIn node all the file and network APIs deal with Buffer chunks. In browserify the\r\nBuffer API is provided by [buffer](https://www.npmjs.org/package/buffer), which\r\nuses augmented typed arrays in a very performant way with fallbacks for old\r\nbrowsers.\r\n\r\nHere's an example of using `Buffer` to convert a base64 string to hex:\r\n\r\n```\r\nvar buf = Buffer('YmVlcCBib29w', 'base64');\r\nvar hex = buf.toString('hex');\r\nconsole.log(hex);\r\n```\r\n\r\nThis example will print:\r\n\r\n```\r\n6265657020626f6f70\r\n```\r\n\r\n## [process](http://nodejs.org/docs/latest/api/process.html#process_process)\r\n\r\nIn node, `process` is a special object that handles information and control for\r\nthe running process such as environment, signals, and standard IO streams.\r\n\r\nOf particular consequence is the `process.nextTick()` implementation that\r\ninterfaces with the event loop.\r\n\r\nIn browserify the process implementation is handled by the\r\n[process module](https://www.npmjs.org/package/process) which just provides\r\n`process.nextTick()` and little else.\r\n\r\nHere's what `process.nextTick()` does:\r\n\r\n```\r\nsetTimeout(function () {\r\n    console.log('third');\r\n}, 0);\r\n\r\nprocess.nextTick(function () {\r\n    console.log('second');\r\n});\r\n\r\nconsole.log('first');\r\n```\r\n\r\nThis script will output:\r\n\r\n```\r\nfirst\r\nsecond\r\nthird\r\n```\r\n\r\n`process.nextTick(fn)` is like `setTimeout(fn, 0)`, but faster because\r\n`setTimeout` is artificially slower in javascript engines for compatibility reasons.\r\n\r\n## [global](http://nodejs.org/docs/latest/api/all.html#all_global)\r\n\r\nIn node, `global` is the top-level scope where global variables are attached\r\nsimilar to how `window` works in the browser. In browserify, `global` is just an\r\nalias for the `window` object.\r\n\r\n## [__filename](http://nodejs.org/docs/latest/api/all.html#all_filename)\r\n\r\n`__filename` is the path to the current file, which is different for each file.\r\n\r\nTo prevent disclosing system path information, this path is rooted at the\r\n`opts.basedir` that you pass to `browserify()`, which defaults to the\r\n[current working directory](https://en.wikipedia.org/wiki/Current_working_directory).\r\n\r\nIf we have a `main.js`:\r\n\r\n``` js\r\nvar bar = require('./foo/bar.js');\r\n\r\nconsole.log('here in main.js, __filename is:', __filename);\r\nbar();\r\n```\r\n\r\nand a `foo/bar.js`:\r\n\r\n``` js\r\nmodule.exports = function () {\r\n    console.log('here in foo/bar.js, __filename is:', __filename);\r\n};\r\n```\r\n\r\nthen running browserify starting at `main.js` gives this output:\r\n\r\n```\r\n$ browserify main.js | node\r\nhere in main.js, __filename is: /main.js\r\nhere in foo/bar.js, __filename is: /foo/bar.js\r\n```\r\n\r\n## [__dirname](http://nodejs.org/docs/latest/api/all.html#all_dirname)\r\n\r\n`__dirname` is the directory of the current file. Like `__filename`, `__dirname`\r\nis rooted at the `opts.basedir`.\r\n\r\nHere's an example of how `__dirname` works:\r\n\r\nmain.js:\r\n\r\n``` js\r\nrequire('./x/y/z/abc.js');\r\nconsole.log('in main.js __dirname=' + __dirname);\r\n```\r\n\r\nx/y/z/abc.js:\r\n\r\n``` js\r\nconsole.log('in abc.js, __dirname=' + __dirname);\r\n```\r\n\r\noutput:\r\n\r\n```\r\n$ browserify main.js | node\r\nin abc.js, __dirname=/x/y/z\r\nin main.js __dirname=/\r\n```\r\n\r\n# transforms\r\n\r\nInstead of browserify baking in support for everything, it supports a flexible\r\ntransform system that are used to convert source files in-place.\r\n\r\nThis way you can `require()` files written in coffee script or templates and\r\neverything will be compiled down to javascript.\r\n\r\nTo use [coffeescript](http://coffeescript.org/) for example, you can use the\r\n[coffeeify](https://www.npmjs.org/package/coffeeify) transform.\r\nMake sure you've installed coffeeify first with `npm install coffeeify` then do:\r\n\r\n```\r\n$ browserify -t coffeeify main.coffee > bundle.js\r\n```\r\n\r\nor with the API you can do:\r\n\r\n```\r\nvar b = browserify('main.coffee');\r\nb.transform('coffeeify');\r\n```\r\n\r\nThe best part is, if you have source maps enabled with `--debug` or\r\n`opts.debug`, the bundle.js will map exceptions back into the original coffee\r\nscript source files. This is very handy for debugging with firebug or chrome\r\ninspector.\r\n\r\n## writing your own\r\n\r\nTransforms implement a simple streaming interface. Here is a transform that\r\nreplaces `$CWD` with the `process.cwd()`:\r\n\r\n``` js\r\nvar through = require('through2');\r\n\r\nmodule.exports = function (file) {\r\n    return through(function (buf, enc, next) {\r\n        this.push(buf.toString('utf8').replace(/\\$CWD/g, process.cwd());\r\n        next();\r\n    });\r\n};\r\n```\r\n\r\nThe transform function fires for every `file` in the current package and returns\r\na transform stream that performs the conversion. The stream is written to and by\r\nbrowserify with the original file contents and browserify reads from the stream\r\nto obtain the new contents.\r\n\r\nSimply save your transform to a file or make a package and then add it with\r\n`-t ./your_transform.js`.\r\n\r\nFor more information about how streams work, check out the\r\n[stream handbook](https://github.com/substack/stream-handbook).\r\n\r\n# package.json\r\n\r\n## browser field\r\n\r\nYou can define a `\"browser\"` field in the package.json of any package that will\r\ntell browserify to override lookups for the main field and for individual\r\nmodules.\r\n\r\nIf you have a module with a main entry point of `main.js` for node but have a\r\nbrowser-specific entry point at `browser.js`, you can do:\r\n\r\n``` json\r\n{\r\n  \"name\": \"mypkg\",\r\n  \"version\": \"1.2.3\",\r\n  \"main\": \"main.js\",\r\n  \"browser\": \"browser.js\"\r\n}\r\n```\r\n\r\nNow when somebody does `require('mypkg')` in node, they will get the exports\r\nfrom `main.js`, but when they do `require('mypkg')` in a browser, they will get\r\nthe exports from `browser.js`.\r\n\r\nSplitting up whether you are in the browser or not with a `\"browser\"` field in\r\nthis way is greatly preferrable to checking whether you are in a browser at\r\nruntime because you may want to load different modules based on whether you are\r\nin node or the browser. If the `require()` calls for both node and the browser\r\nare in the same file, browserify's static analysis will include everything\r\nwhether you use those files or not.\r\n\r\nYou can do more with the \"browser\" field as an object instead of a string.\r\n\r\nFor example, if you only want to swap out a single file in `lib/` with a\r\nbrowser-specific version, you could do:\r\n\r\n``` json\r\n{\r\n  \"name\": \"mypkg\",\r\n  \"version\": \"1.2.3\",\r\n  \"main\": \"main.js\",\r\n  \"browser\": {\r\n    \"lib/foo.js\": \"lib/browser-foo.js\"\r\n  }\r\n}\r\n```\r\n\r\nor if you want to swap out a module used locally in the package, you can do:\r\n\r\n``` json\r\n{\r\n  \"name\": \"mypkg\",\r\n  \"version\": \"1.2.3\",\r\n  \"main\": \"main.js\",\r\n  \"browser\": {\r\n    \"fs\": \"level-fs-browser\"\r\n  }\r\n}\r\n```\r\n\r\nYou can ignore files (setting their contents to the empty object) by setting\r\ntheir values in the browser field to `false`:\r\n\r\n``` json\r\n{\r\n  \"name\": \"mypkg\",\r\n  \"version\": \"1.2.3\",\r\n  \"main\": \"main.js\",\r\n  \"browser\": {\r\n    \"winston\": false\r\n  }\r\n}\r\n```\r\n\r\nThe browser field *only* applies to the current package. Any mappings you put\r\nwill not propagate down to its dependencies or up to its dependents. This\r\nisolation is designed to protect modules from each other so that when you\r\nrequire a module you won't need to worry about any system-wide effects it might\r\nhave. Likewise, you shouldn't need to wory about how your local configuration\r\nmight adversely affect modules far away deep into your dependency graph.\r\n\r\n## browserify.transform field\r\n\r\nYou can configure transforms to be automatically applied when a module is loaded\r\nin a package's `browserify.transform` field. For example, we can automatically\r\napply the [brfs](https://npmjs.org/package/brfs) transform with this\r\npackage.json:\r\n\r\n``` json\r\n{\r\n  \"name\": \"mypkg\",\r\n  \"version\": \"1.2.3\",\r\n  \"main\": \"main.js\",\r\n  \"browserify\": {\r\n    \"transform\": [ \"brfs\" ]\r\n  }\r\n}\r\n```\r\n\r\nNow in our `main.js` we can do:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar src = fs.readFileSync(__dirname + '/foo.txt', 'utf8');\r\n\r\nmodule.exports = function (x) { return src.replace(x, 'zzz') };\r\n```\r\n\r\nand the `fs.readFileSync()` call will be inlined by brfs without consumers of\r\nthe module having to know. You can apply as many transforms as you like in the\r\ntransform array and they will be applied in order.\r\n\r\nLike the `\"browser\"` field, transforms configured in package.json will only\r\napply to the local package for the same reasons.\r\n\r\n# finding good modules\r\n\r\nHere are [some useful heuristics](http://substack.net/finding_modules)\r\nfor finding good modules on npm that work in the browser:\r\n\r\n* I can install it with npm\r\n\r\n* code snippet on the readme using require() - from a quick glance I should see\r\nhow to integrate the library into what I'm presently working on\r\n\r\n* has a very clear, narrow idea about scope and purpose\r\n\r\n* knows when to delegate to other libraries - doesn't try to do too many things itself\r\n\r\n* written or maintained by authors whose opinions about software scope,\r\nmodularity, and interfaces I generally agree with (often a faster shortcut\r\nthan reading the code/docs very closely)\r\n\r\n* inspecting which modules depend on the library I'm evaluating - this is baked\r\ninto the package page for modules published to npm\r\n\r\nOther metrics like number of stars on github, project activity, or a slick\r\nlanding page, are not as reliable.\r\n\r\n## module philosophy\r\n\r\nPeople used to think that exporting a bunch of handy utility-style things would\r\nbe the main way that programmers would consume code because that is the primary\r\nway of exporting and importing code on most other platforms and indeed still\r\npersists even on npm.\r\n\r\nHowever, this\r\n[kitchen-sink mentality](https://github.com/substack/node-mkdirp/issues/17)\r\ntoward including a bunch of thematically-related but separable functionality\r\ninto a single package appears to be an artifact for the difficulty of\r\npublishing and discovery in a pre-github, pre-npm era.\r\n\r\nThere are two other big problems with modules that try to export a bunch of\r\nfunctionality all in one place under the auspices of convenience: demarcation\r\nturf wars and finding which modules do what.\r\n\r\nPackages that are grab-bags of features\r\n[waste a ton of time policing boundaries](https://github.com/jashkenas/underscore/search?q=%22special-case%22&ref=cmdform&type=Issues)\r\nabout which new features belong and don't belong.\r\nThere is no clear natural boundary of the problem domain in this kind of package\r\nabout what the scope is, it's all\r\n[somebody's smug opinion](http://david.heinemeierhansson.com/2012/rails-is-omakase.html).\r\n\r\nNode, npm, and browserify are not that. They are avowedly ala-carte,\r\nparticipatory, and would rather celebrate disagreement and the dizzying\r\nproliferation of new ideas and approaches than try to clamp down in the name of\r\nconformity, standards, or \"best practices\".\r\n\r\nNobody who needs to do gaussian blur ever thinks \"hmm I guess I'll start checking\r\ngeneric mathematics, statistics, image processing, and utility libraries to see\r\nwhich one has gaussian blur in it. Was it stats2 or image-pack-utils or\r\nmaths-extra or maybe underscore has that one?\"\r\nNo. None of this. Stop it. They `npm search gaussian` and they immediately see\r\n[ndarray-gaussian-filter](https://npmjs.org/package/ndarray-gaussian-filter) and\r\nit does exactly what they want and then they continue on with their actual\r\nproblem instead of getting lost in the weeds of somebody's neglected grand\r\nutility fiefdom.\r\n\r\n# organizing modules\r\n\r\n## avoiding ../../../../../../..\r\n\r\nNot everything in an application properly belongs on the public npm and the\r\noverhead of setting up a private npm or git repo is still rather large in many\r\ncases. Here are some approaches for avoiding the `../../../../../../../`\r\nrelative paths problem.\r\n\r\n### node_modules\r\n\r\nPeople sometimes object to putting application-specific modules into\r\nnode_modules because it is not obvious how to check in your internal modules\r\nwithout also checking in third-party modules from npm.\r\n\r\nThe answer is quite simple! If you have a `.gitignore` file that ignores\r\n`node_modules`:\r\n\r\n```\r\nnode_modules\r\n```\r\n\r\nYou can just add an exception with `!` for each of your internal application\r\nmodules:\r\n\r\n```\r\nnode_modules/*\r\n!node_modules/foo\r\n!node_modules/bar\r\n```\r\n\r\nPlease note that you can't *unignore* a subdirectory,\r\nif the parent is already ignored. So instead of ignoring `node_modules`,\r\nyou have to ignore every directory *inside* `node_modules` with the \r\n`node_modules/*` trick, and then you can add your exceptions.\r\n\r\nNow anywhere in your application you will be able to `require('foo')` or\r\n`require('bar')` without having a very large and fragile relative path.\r\n\r\nIf you have a lot of modules and want to keep them more separate from the\r\nthird-party modules installed by npm, you can just put them all under a\r\ndirectory in `node_modules` such as `node_modules/app`:\r\n\r\n```\r\nnode_modules/app/foo\r\nnode_modules/app/bar\r\n```\r\n\r\nNow you will be able to `require('app/foo')` or `require('app/bar')` from\r\nanywhere in your application.\r\n\r\nIn your `.gitignore`, just add an exception for `node_modules/app`:\r\n\r\n```\r\nnode_modules/*\r\n!node_modules/app\r\n```\r\n\r\nIf your application had transforms configured in package.json, you'll need to\r\ncreate a separate package.json with its own transform field in your\r\n`node_modules/foo` or `node_modules/app/foo` component directory because\r\ntransforms don't apply across module boundaries. This will make your modules\r\nmore robust against configuration changes in your application and it will be\r\neasier to independently reuse the packages outside of your application.\r\n\r\n### symlink\r\n\r\nAnother handy trick if you are working on an application where you can make\r\nsymlinks and don't need to support windows is to symlink a `lib/` or `app/`\r\nfolder into `node_modules`. From the project root, do:\r\n\r\n```\r\nln -s ../lib node_modules/app\r\n```\r\n\r\nand now from anywhere in your project you'll be able to require files in `lib/`\r\nby doing `require('app/foo.js')` to get `lib/foo.js`.\r\n\r\n### custom paths\r\n\r\nYou might see some places talk about using the `$NODE_PATH` environment variable\r\nor `opts.paths` to add directories for node and browserify to look in to find\r\nmodules.\r\n\r\nUnlike most other platforms, using a shell-style array of path directories with\r\n`$NODE_PATH` is not as favorable in node compared to making effective use of the\r\n`node_modules` directory.\r\n\r\nThis is because your application is more tightly coupled to a runtime\r\nenvironment configuration so there are more moving parts and your application\r\nwill only work when your environment is setup correctly.\r\n\r\nnode and browserify both support but discourage the use of `$NODE_PATH`.\r\n\r\n## non-javascript assets\r\n\r\nThere are many\r\n[browserify transforms](https://github.com/substack/node-browserify/wiki/list-of-transforms)\r\nyou can use to do many things. Commonly, transforms are used to include\r\nnon-javascript assets into bundle files.\r\n\r\n### brfs\r\n\r\nOne way of including any kind of asset that works in both node and the browser\r\nis brfs.\r\n\r\nbrfs uses static analysis to compile the results of `fs.readFile()` and\r\n`fs.readFileSync()` calls down to source contents at compile time.\r\n\r\nFor example, this `main.js`:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar html = fs.readFileSync(__dirname + '/robot.html', 'utf8');\r\nconsole.log(html);\r\n```\r\n\r\napplied through brfs would become something like:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar html = \"<b>beep boop</b>\";\r\nconsole.log(html);\r\n```\r\n\r\nwhen run through brfs.\r\n\r\nThis is handy because you can reuse the exact same code in node and the browser,\r\nwhich makes sharing modules and testing much simpler.\r\n\r\n`fs.readFile()` and `fs.readFileSync()` accept the same arguments as in node,\r\nwhich makes including inline image assets as base64-encoded strings very easy:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar imdata = fs.readFileSync(__dirname + '/image.png', 'base64');\r\nvar img = document.createElement('img');\r\nimg.setAttribute('src', 'data:image/png;base64,' + imdata);\r\ndocument.body.appendChild(img);\r\n```\r\n\r\nIf you have some css you want to inline into your bundle, you can do that too\r\nwith the assistence of a module such as\r\n[insert-css](https://npmjs.org/package/insert-css):\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar insertStyle = require('insert-css');\r\n\r\nvar css = fs.readFileSync(__dirname + '/style.css', 'utf8');\r\ninsertStyle(css);\r\n```\r\n\r\nInserting css this way works fine for small reusable modules that you distribute\r\nwith npm because they are fully-contained, but if you want a more wholistic\r\napproach to asset management using browserify, check out \r\n[atomify](https://www.npmjs.org/package/atomify) and\r\n[parcelify](https://www.npmjs.org/package/parcelify).\r\n\r\n### hbsify\r\n\r\n### jadeify\r\n\r\n### reactify\r\n\r\n## reusable components\r\n\r\nPutting these ideas about code organization together, we can build a reusable UI\r\ncomponent that we can reuse across our application or in other applications.\r\n\r\nHere is a bare-bones example of an empty widget module:\r\n\r\n``` js\r\nmodule.exports = Widget;\r\n\r\nfunction Widget (opts) {\r\n    if (!(this instanceof Widget)) return new Widget(opts);\r\n    this.element = document.createElement('div');\r\n}\r\n\r\nWidget.prototype.appendTo = function (target) {\r\n    if (typeof target === 'string') target = document.querySelector(target);\r\n    target.appendChild(this.element);\r\n};\r\n```\r\n\r\nHandy javascript constructor tip: you can include a `this instanceof Widget`\r\ncheck like above to let people consume your module with `new Widget` or\r\n`Widget()`. It's nice because it hides an implementation detail from your API\r\nand you still get the performance benefits and indentation wins of using\r\nprototypes.\r\n\r\nTo use this widget, just use `require()` to load the widget file, instantiate\r\nit, and then call `.appendTo()` with a css selector string or a dom element.\r\n\r\nLike this:\r\n\r\n``` js\r\nvar Widget = require('./widget.js');\r\nvar w = Widget();\r\nw.appendTo('#container');\r\n```\r\n\r\nand now your widget will be appended to the DOM.\r\n\r\nCreating HTML elements procedurally is fine for very simple content but gets\r\nvery verbose and unclear for anything bigger. Luckily there are many transforms\r\navailable to ease importing HTML into your javascript modules.\r\n\r\nLet's extend our widget example using [brfs](https://npmjs.org/package/brfs). We\r\ncan also use [domify](https://npmjs.org/package/domify) to turn the string that\r\n`fs.readFileSync()` returns into an html dom element:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar domify = require('domify');\r\n\r\nvar html = fs.readFileSync(__dirname + '/widget.html', 'utf8');\r\n\r\nmodule.exports = Widget;\r\n\r\nfunction Widget (opts) {\r\n    if (!(this instanceof Widget)) return new Widget(opts);\r\n    this.element = domify(html);\r\n}\r\n\r\nWidget.prototype.appendTo = function (target) {\r\n    if (typeof target === 'string') target = document.querySelector(target);\r\n    target.appendChild(this.element);\r\n};\r\n```\r\n\r\nand now our widget will load a `widget.html`, so let's make one:\r\n\r\n``` html\r\n<div class=\"widget\">\r\n  <h1 class=\"name\"></h1>\r\n  <div class=\"msg\"></div>\r\n</div>\r\n```\r\n\r\nIt's often useful to emit events. Here's how we can emit events using the\r\nbuilt-in `events` module and the [inherits](https://npmjs.org/package/inherits)\r\nmodule:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar domify = require('domify');\r\nvar inherits = require('inherits');\r\nvar EventEmitter = require('events').EventEmitter;\r\n\r\nvar html = fs.readFileSync(__dirname + '/widget.html', 'utf8');\r\n\r\ninherits(Widget, EventEmitter);\r\nmodule.exports = Widget;\r\n\r\nfunction Widget (opts) {\r\n    if (!(this instanceof Widget)) return new Widget(opts);\r\n    this.element = domify(html);\r\n}\r\n\r\nWidget.prototype.appendTo = function (target) {\r\n    if (typeof target === 'string') target = document.querySelector(target);\r\n    target.appendChild(this.element);\r\n    this.emit('append', target);\r\n};\r\n```\r\n\r\nNow we can listen for `'append'` events on our widget instance:\r\n\r\n``` js\r\nvar Widget = require('./widget.js');\r\nvar w = Widget();\r\nw.on('append', function (target) {\r\n    console.log('appended to: ' + target.outerHTML);\r\n});\r\nw.appendTo('#container');\r\n```\r\n\r\nWe can add more methods to our widget to set elements on the html:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar domify = require('domify');\r\nvar inherits = require('inherits');\r\nvar EventEmitter = require('events').EventEmitter;\r\n\r\nvar html = fs.readFileSync(__dirname + '/widget.html', 'utf8');\r\n\r\ninherits(Widget, EventEmitter);\r\nmodule.exports = Widget;\r\n\r\nfunction Widget (opts) {\r\n    if (!(this instanceof Widget)) return new Widget(opts);\r\n    this.element = domify(html);\r\n}\r\n\r\nWidget.prototype.appendTo = function (target) {\r\n    if (typeof target === 'string') target = document.querySelector(target);\r\n    target.appendChild(this.element);\r\n};\r\n\r\nWidget.prototype.setName = function (name) {\r\n    this.element.querySelector('.name').textContent = name;\r\n}\r\n\r\nWidget.prototype.setMessage = function (msg) {\r\n    this.element.querySelector('.msg').textContent = msg;\r\n}\r\n```\r\n\r\nIf setting element attributes and content gets too verbose, check out\r\n[hyperglue](https://npmjs.org/package/hyperglue).\r\n\r\nNow finally, we can toss our `widget.js` and `widget.html` into\r\n`node_modules/app-widget`. Since our widget uses the\r\n[brfs](https://npmjs.org/package/brfs) transform, we can create a `package.json`\r\nwith:\r\n\r\n``` json\r\n{\r\n  \"name\": \"app-widget\",\r\n  \"version\": \"1.0.0\",\r\n  \"private\": true,\r\n  \"main\": \"widget.js\",\r\n  \"browserify\": {\r\n    \"transform\": [ \"brfs\" ]\r\n  },\r\n  \"dependencies\": {\r\n    \"brfs\": \"^1.1.1\",\r\n    \"inherits\": \"^2.0.1\"\r\n  }\r\n}\r\n```\r\n\r\nAnd now whenever we `require('app-widget')` from anywhere in our application,\r\nbrfs will be applied to our `widget.js` automatically!\r\nOur widget can even maintain its own dependencies. This way we can update\r\ndependencies in one widgets without worrying about breaking changes cascading\r\nover into other widgets.\r\n\r\nMake sure to add an exclusion in your `.gitignore` for\r\n`node_modules/app-widget`:\r\n\r\n```\r\nnode_modules/*\r\n!node_modules/app-widget\r\n```\r\n\r\nYou can read more about [shared rendering in node and the\r\nbrowser](http://substack.net/shared_rendering_in_node_and_the_browser) if you\r\nwant to learn about sharing rendering logic between node and the browser using\r\nbrowserify and some streaming html libraries.\r\n\r\n# testing in node and the browser\r\n\r\nTesting modular code is very easy! One of the biggest benefits of modularity is\r\nthat your interfaces become much easier to instantiate in isolation and so it's\r\neasy to make automated tests.\r\n\r\nUnfortunately, few testing libraries play nicely out of the box with modules and\r\ntend to roll their own idiosyncratic interfaces with implicit globals and obtuse\r\nflow control that get in the way of a clean design with good separation.\r\n\r\nPeople also make a huge fuss about \"mocking\" but it's usually not necessary if\r\nyou design your modules with testing in mind. Keeping IO separate from your\r\nalgorithms, carefully restricting the scope of your module, and accepting\r\ncallback parameters for different interfaces can all make your code much easier\r\nto test.\r\n\r\nFor example, if you have a library that does both IO and speaks a protocol,\r\n[consider separating the IO layer from the\r\nprotocol](https://www.youtube.com/watch?v=g5ewQEuXjsQ#t=12m30)\r\nusing an interface like [streams](https://github.com/substack/stream-handbook).\r\n\r\nYour code will be easier to test and reusable in different contexts that you\r\ndidn't initially envision. This is a recurring theme of testing: if your code is\r\nhard to test, it is probably not modular enough or contains the wrong balance of\r\nabstractions. Testing should not be an afterthought, it should inform your\r\nwhole design and it will help you to write better interfaces.\r\n\r\n## testing libraries\r\n\r\n### [tape](https://npmjs.org/package/tape)\r\n\r\nTape was specifically designed from the start to work well in both node and\r\nbrowserify. Suppose we have an `index.js` with an async interface:\r\n\r\n``` js\r\nmodule.exports = function (x, cb) {\r\n    setTimeout(function () {\r\n        cb(x * 100);\r\n    }, 1000);\r\n};\r\n```\r\n\r\nHere's how we can test this module using [tape](https://npmjs.org/package/tape). \r\nLet's put this file in `test/beep.js`:\r\n\r\n``` js\r\nvar test = require('tape');\r\nvar hundreder = require('../');\r\n\r\ntest('beep', function (t) {\r\n    t.plan(1);\r\n    \r\n    hundreder(5, function (n) {\r\n        t.equal(n, 500, '5*100 === 500');\r\n    });\r\n});\r\n```\r\n\r\nBecause the test file lives in `test/`, we can require the `index.js` in the\r\nparent directory by doing `require('../')`. `index.js` is the default place that\r\nnode and browserify look for a module if there is no package.json in that\r\ndirectory with a `main` field.\r\n\r\nWe can `require()` tape like any other library after it has been installed with\r\n`npm install tape`.\r\n\r\nThe string `'beep'` is an optional name for the test.\r\nThe 3rd argument to `t.equal()` is a completely optional description.\r\n\r\nThe `t.plan(1)` says that we expect 1 assertion. If there are not enough\r\nassertions or too many, the test will fail. An assertion is a comparison\r\nlike `t.equal()`. tape has assertion primitives for:\r\n\r\n* t.equal(a, b) - compare a and b strictly with `===`\r\n* t.deepEqual(a, b) - compare a and b recursively\r\n* t.ok(x) - fail if `x` is not truthy\r\n\r\nand more! You can always add an additional description argument.\r\n\r\nRunning our module is very simple! To run the module in node, just run\r\n`node test/beep.js`:\r\n\r\n```\r\n$ node test/beep.js\r\nTAP version 13\r\n# beep\r\nok 1 5*100 === 500\r\n\r\n1..1\r\n# tests 1\r\n# pass  1\r\n\r\n# ok\r\n```\r\n\r\nThe output is printed to stdout and the exit code is 0.\r\n\r\nTo run our code in the browser, just do:\r\n\r\n```\r\n$ browserify test/beep.js > bundle.js\r\n```\r\n\r\nthen plop `bundle.js` into a `<script>` tag:\r\n\r\n```\r\n<script src=\"bundle.js\"></script>\r\n```\r\n\r\nand load that html in a browser. The output will be in the debug console which\r\nyou can open with F12, ctrl-shift-j, or ctrl-shift-k depending on the browser.\r\n\r\nThis is a bit cumbersome to run our tests in a browser, but you can install the\r\n`testling` command to help. First do:\r\n\r\n```\r\nnpm install -g testling\r\n```\r\n\r\nAnd now just do `browserify test/beep.js | testling`:\r\n\r\n```\r\n$ browserify test/beep.js | testling\r\n\r\nTAP version 13\r\n# beep\r\nok 1 5*100 === 500\r\n\r\n1..1\r\n# tests 1\r\n# pass  1\r\n\r\n# ok\r\n```\r\n\r\n`testling` will launch a real browser headlessly on your system to run the tests.\r\n\r\nNow suppose we want to add another file, `test/boop.js`:\r\n\r\n``` js\r\nvar test = require('tape');\r\nvar hundreder = require('../');\r\n\r\ntest('fraction', function (t) {\r\n    t.plan(1);\r\n\r\n    hundreder(1/20, function (n) {\r\n        t.equal(n, 5, '1/20th of 100');\r\n    });\r\n});\r\n\r\ntest('negative', function (t) {\r\n    t.plan(1);\r\n\r\n    hundreder(-3, function (n) {\r\n        t.equal(n, -300, 'negative number');\r\n    });\r\n});\r\n```\r\n\r\nHere our test has 2 `test()` blocks. The second test block won't start to\r\nexecute until the first is completely finished, even though it is asynchronous.\r\nYou can even nest test blocks by using `t.test()`.\r\n\r\nWe can run `test/boop.js` with node directly as with `test/beep.js`, but if we\r\nwant to run both tests, there is a minimal command-runner we can use that comes\r\nwith tape. To get the `tape` command do:\r\n\r\n```\r\nnpm install -g tape\r\n```\r\n\r\nand now you can run:\r\n\r\n```\r\n$ tape test/*.js\r\nTAP version 13\r\n# beep\r\nok 1 5*100 === 500\r\n# fraction\r\nok 2 1/20th of 100\r\n# negative\r\nok 3 negative number\r\n\r\n1..3\r\n# tests 3\r\n# pass  3\r\n\r\n# ok\r\n```\r\n\r\nand you can just pass `test/*.js` to browserify to run your tests in the\r\nbrowser:\r\n\r\n```\r\n$ browserify test/* | testling\r\n\r\nTAP version 13\r\n# beep\r\nok 1 5*100 === 500\r\n# fraction\r\nok 2 1/20th of 100\r\n# negative\r\nok 3 negative number\r\n\r\n1..3\r\n# tests 3\r\n# pass  3\r\n\r\n# ok\r\n```\r\n\r\nPutting together all these steps, we can configure `package.json` with a test\r\nscript:\r\n\r\n``` json\r\n{\r\n  \"name\": \"hundreder\",\r\n  \"version\": \"1.0.0\",\r\n  \"main\": \"index.js\",\r\n  \"devDependencies\": {\r\n    \"tape\": \"^2.13.1\",\r\n    \"testling\": \"^1.6.1\"\r\n  },\r\n  \"scripts\": {\r\n    \"test\": \"tape test/*.js\",\r\n    \"test-browser\": \"browserify test/*.js | testlingify\"\r\n  }\r\n}\r\n```\r\n\r\nNow you can do `npm test` to run the tests in node and `npm run test-browser` to\r\nrun the tests in the browser. You don't need to worry about installing commands\r\nwith `-g` when you use `npm run`: npm automatically sets up the `$PATH` for all\r\npackages installed locally to the project.\r\n\r\nIf you have some tests that only run in node and some tests that only run in the\r\nbrowser, you could have subdirectories in `test/` such as `test/server` and\r\n`test/browser` with the tests that run both places just in `test/`. Then you\r\ncould just add the relevant directory to the globs:\r\n\r\n``` json\r\n{\r\n  \"name\": \"hundreder\",\r\n  \"version\": \"1.0.0\",\r\n  \"main\": \"index.js\",\r\n  \"devDependencies\": {\r\n    \"tape\": \"^2.13.1\",\r\n    \"testling\": \"^1.6.1\"\r\n  },\r\n  \"scripts\": {\r\n    \"test\": \"tape test/*.js test/server/*.js\",\r\n    \"test-browser\": \"browserify test/*.js test/browser/*.js | testlingify\"\r\n  }\r\n}\r\n```\r\n\r\nand now server-specific and browser-specific tests will be run in addition to\r\nthe common tests.\r\n\r\nIf you want something even slicker, check out\r\n[prova](https://www.npmjs.org/package/prova) once you have gotten the basic\r\nconcepts.\r\n\r\n### assert\r\n\r\nThe core assert module is a fine way to write simple tests too, although it can\r\nsometimes be tricky to ensure that the correct number of callbacks have fired.\r\n\r\nYou can solve that problem with tools like\r\n[macgyver](https://www.npmjs.org/package/macgyver) but it is appropriately DIY.\r\n\r\n### mocha\r\n\r\n\r\n## code coverage\r\n\r\n## testling-ci\r\n\r\n# bundling\r\n\r\nThis section covers bundling in more detail.\r\n\r\nBundling is the step where starting from the entry files, all the source files\r\nin the dependency graph are walked and packed into a single output file.\r\n\r\n## saving bytes\r\n\r\nOne of the first things you'll want to tweak is how the files that npm installs\r\nare placed on disk to avoid duplicates.\r\n\r\nWhen you do a clean install in a directory, npm will ordinarily factor out\r\nsimilar versions into the topmost directory where 2 modules share a dependency.\r\nHowever, as you install more packages, new packages will not be factored out\r\nautomatically. You can however use the `npm dedupe` command to factor out\r\npackages for an already-installed set of packages in `node_modules/`. You could\r\nalso remove `node_modules/` and install from scratch again if problems with\r\nduplicates persist.\r\n\r\nbrowserify will not include the same exact file twice, but compatible versions\r\nmay differ slightly. browserify is also not version-aware, it will include the\r\nversions of packages exactly as they are laid out in `node_modules/` according\r\nto the `require()` algorithm that node uses.\r\n\r\nYou can use the `browserify --list` and `browserify --deps` commands to further\r\ninspect which files are being included to scan for duplicates.\r\n\r\n## standalone\r\n\r\nYou can generate UMD bundles with `--standalone` that will work in node, the\r\nbrowser with globals, and AMD environments.\r\n\r\nJust add `--standalone NAME` to your bundle command:\r\n\r\n```\r\n$ browserify foo.js --standalone xyz > bundle.js\r\n```\r\n\r\nThis command will export the contents of `foo.js` under the external module name\r\n`xyz`. If a module system is detected in the host environment, it will be used.\r\nOtherwise a window global named `xyz` will be exported.\r\n\r\nYou can use dot-syntax to specify a namespace hierarchy:\r\n\r\n```\r\n$ browserify foo.js --standalone foo.bar.baz > bundle.js\r\n```\r\n\r\nIf there is already a `foo` or a `foo.bar` in the host environment in window\r\nglobal mode, browserify will attach its exports onto those objects. The AMD and\r\n`module.exports` modules will behave the same.\r\n\r\nNote however that standalone only works with a single entry or directly-required\r\nfile.\r\n\r\n## external bundles\r\n\r\n## ignoring and excluding\r\n\r\nIn browserify parlance, \"ignore\" means: replace the definition of a module with\r\nan empty object. \"exclude\" means: remove a module completely from a dependency graph.\r\n\r\nAnother way to achieve many of the same goals as ignore and exclude is the\r\n\"browser\" field in package.json, which is covered elsewhere in this document.\r\n\r\n### ignoring\r\n\r\nIgnoring is an optimistic strategy designed to stub in an empty definition for\r\nnode-specific modules that are only used in some codepaths. For example, if a\r\nmodule requires a library that only works in node but for a specific chunk of\r\nthe code:\r\n\r\n``` js\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar mkdirp = require('mkdirp');\r\n\r\nexports.convert = convert;\r\nfunction convert (src) {\r\n    return src.replace(/beep/g, 'boop');\r\n}\r\n\r\nexports.write = function (src, dst, cb) {\r\n    fs.readFile(src, function (err, src) {\r\n        if (err) return cb(err);\r\n        mkdirp(path.dirname(dst), function (err) {\r\n            if (err) return cb(err);\r\n            var out = convert(src);\r\n            fs.writeFile(dst, out, cb);\r\n        });\r\n    });\r\n};\r\n```\r\n\r\nbrowserify already \"ignores\" the `'fs'` module by returning an empty object, but\r\nthe `.write()` function here won't work in the browser without an extra step like\r\na static analysis transform or a runtime storage fs abstraction.\r\n\r\nHowever, if we really want the `convert()` function but don't want to see\r\n`mkdirp` in the final bundle, we can ignore mkdirp with `b.ignore('mkdirp')` or\r\n`browserify --ignore mkdirp`. The code will still work in the browser if we\r\ndon't call `write()` because `require('mkdirp')` won't throw an exception, just\r\nreturn an empty object.\r\n\r\nGenerally speaking it's not a good idea for modules that are primarily\r\nalgorithmic (parsers, formatters) to do IO themselves but these tricks can let\r\nyou use those modules in the browser anyway.\r\n\r\nTo ignore `foo` on the command-line do:\r\n\r\n```\r\nbrowserify --ignore foo\r\n```\r\n\r\nTo ignore `foo` from the api with some bundle instance `b` do:\r\n\r\n``` js\r\nb.ignore('foo')\r\n```\r\n\r\n### excluding\r\n\r\nAnother related thing we might want is to completely remove a module from the\r\noutput so that `require('modulename')` will fail at runtime. This is useful if\r\nwe want to split things up into multiple bundles that will defer in a cascade to\r\npreviously-defined `require()` definitions.\r\n\r\nFor example, if we have a vendored standalone bundle for jquery that we don't want to appear in\r\nthe primary bundle:\r\n\r\n```\r\n$ npm install jquery\r\n$ browserify -r jquery --standalone jquery > jquery-bundle.js\r\n```\r\n\r\nthen we want to just `require('jquery')` in a `main.js`:\r\n\r\n``` js\r\nvar $ = require('jquery');\r\n$(window).click(function () { document.body.bgColor = 'red' });\r\n```\r\n\r\ndefering to the jquery dist bundle so that we can write:\r\n\r\n``` html\r\n<script src=\"jquery-bundle.js\"></script>\r\n<script src=\"bundle.js\"></script>\r\n```\r\n\r\nand not have the jquery definition show up in `bundle.js`, then while compiling\r\nthe `main.js`, you can `--exclude jquery`:\r\n\r\n```\r\nbrowserify main.js --exclude jquery > bundle.js\r\n```\r\n\r\nTo exclude `foo` on the command-line do:\r\n\r\n```\r\nbrowserify --exclude foo\r\n```\r\n\r\nTo exclude `foo` from the api with some bundle instance `b` do:\r\n\r\n``` js\r\nb.exclude('foo')\r\n```\r\n\r\n## browserify cdn\r\n\r\n# compiler pipeline\r\n\r\n## module-deps\r\n\r\n## browser-pack\r\n\r\n## insert-module-globals\r\n\r\n## build your own browserify\r\n\r\n## browser-unpack\r\n\r\n## plugins\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}